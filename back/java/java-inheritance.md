# Java - Inheritance\(상속\)

> 각 관련 개념의 예제는 다음의 경로에서 확인이 가능하다  
> [관련 예제 패키지](https://github.com/GodChiken/JavaTheory/tree/master/src/main/java/com/kbh/desk/theory/basic/polymorphism/inheritance)

* 개요    
  * 상위 클래스의 구성물을 하위 클래스에서도 활용 가능하게 하여 코드의 재사용성을 추구하는 것이 상속이다.
  * 연관 객체를 is-a 로 성립시키는 것이다. 
* 장점  
  * 상위 클래스의 필드 및 공통 메서드를 재사용 함으로 하위 클래스의 코드의 양이 줄어듬
* 단점
  * 상속 구조가 복잡해지 상위 클래스의 변화에 따른 하위 클래스에 영향을 예측하기 어렵다.   
* 클래스 상속
  * 다음과 같은 형식으로 기술한다.

    ```java
    class 자식클래스 extends 부모클래스{  // 필드  // 생성자  // 메서드}
    ```

  * 다중 상속이 불가하다.

    ```java
    class 자식클래스 extends 부모클래스1 /*,부모클래스2*/{  // 필드  // 생성자  // 메서드}
    ```
* 부모 생성자의 호출
  * 자바에서는 자식 객체를 생성 시, 부모 객체가 먼저 생성된 후에 생성된다.
  * 모든 객체는 클래스의 생성자를 호출해야 생성된다. 부모 객체도 예외는 아니다.
  * 자식 클래스의 생성자를 명시적으로 선언하지 않으면 다음과 같이 기본 생성자를 컴파일러는 생성하여 부모 생성자를 호출한다.

    ```java
    public class Child extends Parent {  super(); ---> 컴파일러가 생성}public class Parent {  /* 부모 생성자를 호출 */}
    ```

  * 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성한다.
  * 파라미터의 구성을 동일하게 가져야 작동한다.

    > 조금 더 자세히 이야기해 부모 생성자 호출 시 부모 생성자의 파라미터의 개수, 타입, 순서를 동일하게 호출해야 한다.

  * super\(\) 를 반드시 자식생성자의 첫출에 호출해야 에러가 발생하지 않는다.

    ```java
    public class Child {  public Child(){      super();  }}
    ```
* 메소드 재정의
  * 부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계된다면 이상적인 상속 구조이지만, 자식 클래스가 사용하기 적합하지 않을 경우 위의 개념을 사용한다.
  * 당연한 이야기이겠지만, 부모 메소드와 동일한 구조를 가져야한다.
  * 부모 메소드보다 더 강한 접근 제한자는 활용할 수 없다.
  * 부모 메소드에 정의된 throws 의 익셉션을 새로운 예외로 정의할 수 없다.
* final keyword
  * 클래스, 필드, 메서드 선언 시 사용 가능하다.
  * 최종적으로 결정됬다는 의미로 절대로 수정이 될 수 없다.
  * 클래스에 붙이는 경우 상속을 할 수 없다.
  * 메서드에 붙이는 경우 오버라이딩이 불가하다.
  * 필드에 붙이는 경우 값의 수정이 불가하다.
* 접근 제한자.
  * public, protected, default, private 네가지 종류가 있다.

    | 접근 제한자 | 적용할 내용 | 접근할 수 없는 클래스 |
    | :--- | :--- | :--- |
    | public | 클래스, 필드, 생성자, 메서드 | 없음 |
    | protected | 필드, 생성자, 메소드 | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
    | default | 클래스, 필드, 생성자, 메서드 | 다른 패키지에 소속된 클래스 |
    | private | 필드, 생성자, 메서드 | 모든 외부 클래스 |
* 추상 클래스
  * 추상 클래스는 여러 개의 클래스에서 공통적인 사항을 추출하여 선언한 클래스를 의미한다.
  * 추상 클래스는 객체를 직접 생성하여 사용할 수 없다.
  * 용도
    * 추상 클래스를 상속받는 실체 클래스들의 필드,메서드를 공통화 하기 위한 목적을 가지고 있다.
    * 실체 클래스를 작성시 시간단축의 목적을 가지고 있다.
* 추상 메소드와 오버라이딩
  * 메소드의 선언만 통일화 하고, 실행 내용은 실체 클래스 마다 달라야하는 경우가 있다.
  * 일반 메소드와의 차이점은 메소드 부분에서 선언부만 존재하고 "{}"와 같은 구현부가 없는 구조를 가진다.
  * 다음과 같은 구조를 띄게 된다.

    > \[public \| protected\] abstract \[리턴타입\] \[메소드명\] \(\[파라미터\]\);

